#ifndef __THREADPOOL_H
#define __THREADPOOL_H

#include "Particle.h"

class ThreadPool; // forward declaration

/**
 * @brief Class to hold state for a single thread in the thread pool
 */
class ThreadPoolThread {
public:
	/**
	 * @brief Holds state for a single thread in the thread pool; instantiated when the thread pool is instantiated
	 *
	 * @param threadPool The ThreadPool this thread is part of
	 *
	 * @param name of the thread (generated by the thread pool)
	 *
	 * @param priority worker thread priority (passed into ThreadPool)
	 *
	 * @param stackSize worker thread stack size (passed into ThreadPool)
	 */
	ThreadPoolThread(ThreadPool *threadPool, const char *name, os_thread_prio_t priority, size_t stackSize);

	/**
	 * @brief This object isn't actually ever destroyed
	 */
	virtual ~ThreadPoolThread();

	/**
	 * @brief Called from staticRun when the thread is run. Never returns!
	 */
	void run();

	/**
	 * @brief Thread run function. Never returns!
	 */
	static void staticRun(void *param);

private:
	ThreadPool *threadPool;
    os_thread_t thread;
};

/**
 * @brief State data for a call
 */
typedef struct {
	std::function<void(void)> fn;
} ThreadPoolCall;

/**
 * @brief Class for a set of threads in a pool
 */
class ThreadPool {
public:
	/**
	 * @brief A thread pool to execute functions on threads
	 *
	 * @param numThreads The number of threads - this is the number of functions that can be executed simultaneously.
	 *
	 * @param numCalls The number of calls that can be queued. This allows calls to be stacked in up in the queue, waiting
	 * for a free thread to execute the call.
	 *
	 * @param priority The priority for each of the worker threads.
	 *
	 * @param stackSize The stack size for each of the worker threads.
	 */
	ThreadPool(size_t numThreads, size_t numCalls, os_thread_prio_t priority = OS_THREAD_PRIORITY_DEFAULT, size_t stackSize = OS_THREAD_STACK_SIZE_DEFAULT);
	virtual ~ThreadPool();

	/**
	 * @brief Call a function on a thread in the thread pool
	 *
	 * @param fn The function to call. If you want to pass additional data, use a C++11 lambda.
	 *
	 * @param delay Amount of time to wait for a free call entry. Default is to fail immediately if the queue is full.
	 *
	 * @return true if the call was queued or false if the call could not be queued.
	 */
	bool callOnThread(std::function<void(void)> fn, system_tick_t delay = 0);


private:
	/**
	 * @brief Used by ThreadPoolThread to run the next available queued call
	 *
	 * Blocks until a call is available. Returns when the call has been processed. This is called in a
	 * loop within ThreadPoolThread.
	 */
	void runCall();

	os_queue_t callQueue;
	os_queue_t freeQueue;
	size_t numThreads;
	ThreadPoolThread **threads;
	friend class ThreadPoolThread;
};




#endif /* __THREADPOOL_H */
